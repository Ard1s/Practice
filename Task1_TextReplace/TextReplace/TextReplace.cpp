#include <stdio.h>
#include <string.h>

// Функция определения индекса первого фхождения последовательности Sub размером L2
// в последовательность Buf размером L2
// Возвращает -1, если вхождения не нейдены
int MyStrStr(char Buf[], size_t L1, char* Sub, size_t L2)
{
int i;

if(!L2) return -1;       // Пустая подстрока - вхождений нет
for(i=0;i<=L1-L2;i++)    // Перебор всех возможных подстрок
 if(!memcmp(&Buf[i],Sub,L2)) return i;  // Сравнение байтов в памяти
return -1;  // Подстрока не найдена
}


// Параметры:
// argv[1] - имя входного файла
// argv[2] - имя выходного файла
// argv[3] - заменяемая последовательность
// argv[4] - заменяющая последовательность
int main(int argc, char* argv[])
{
FILE *F,*G;      // Входной и выходной файлы
char Buf[1024];  // Символьный буфер
size_t L,dL,L3,L4,i;
int Sub,Fend=0;  // Инициализация флага конца файла
// Поскольку аргументы командной строки имеют тип char*,
// то здесь использовать strlen МОЖНО (и нужно, иначе длины последовательностей никак не узнать)
L3=strlen(argv[3]);     // Расчёт длин последовательностей
L4=strlen(argv[4]);
// Обработка
F=fopen(argv[1],"rb");  // Открытие файла на чтение
G=fopen(argv[2],"wb");  // Создание выходного файла
L=fread(Buf,1,512,F);   // Первое чтение в буфер
if(L<512) Fend=1;       // Файл не больше 512 байт - установить флаг конца файла
// Дальнейшая загрузка идёт блоками по 512 байт после того,
// как опустошится половина буфера и больше
do
 {
// Требуется загрузка очередного блока?
 if(!Fend && L<=512)
  {
  dL=fread(&Buf[L],1,512,F);  // Да - загрузить его
  L+=dL;                      // Инкремент размера данных
  if(dL<512) Fend=1;          // Установка флага конца файла
  }
// Обработка буфера
 while(L>512 || (Fend && L))
  {
  Sub=MyStrStr(Buf,L,argv[3],L3);   // Поиск подстроки
  if(Sub<0)                   // Подстрока не найдена
   {
   if(Fend) fwrite(Buf,1,L,G);     // Если файл закончился - записать остаток буфера
    else fwrite(Buf,1,512,G);      // Иначе - первую половину буфера
   break;                     // И прекратить обработку
   }
  fwrite(Buf,1,Sub,G);        // Запись буфера до подстроки
  fwrite(argv[4],1,L4,G);     // Запись заменяющей последовательности
  Sub+=L3;                    // Кол-во удаляемых символов
  for(i=Sub;i<=L;i++)         // Удаление первых dL символов из буфера
   Buf[i-Sub]=Buf[i];         // Путём сдвига влево
  L-=Sub;                     // Декремент длины строки в буфере
  }
 }
while(!Fend);
fclose(F);          // Закрытие файлов
fclose(G);
return 0;
}